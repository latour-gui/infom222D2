# Title     : Loopback
# Created by: Guillaume <taz> Latour
# Created on: 02/11/2020

# allow the use of pipes for easy function composition
library(magrittr)

#' Tell wether or not the job is put back in the queue after completing its service
#' Rely on the uniform law in ]0,1[
#'
#' @param p float : The probability of a job to be sent in the queue again
#' @return bool   : true if the job is put back in the queue, false otherwise
loopback <- function(p = 0.1) {
  runif(1) < p
}

#' Replace each element by the sum of all the previous ones and itself
#'
#' @elems c(float)  : The sequence of elements that we want to transform
#' @return c(float) : A sequence of the partial sums
partial_sum <- function(elems) {
  sum <- 0
  tab <- numeric(length(elems)) # set up tab's length to avoid array copy at each iteration of the loop
  for (i in seq_along(elems)) {
    sum <- sum + elems[i]
    tab[i] <- sum
  }
  tab
}

#' Simple Server Queue with LoopBack
#'
#' This will simulate a queue of `n` jobs (which have their interarrivals time generated by a normal law) beeing
#' processed by a server (which service time is generated by another normal law) and that have a certain probability of
#' beeing replaced in the queue after service completion.
#'
#' Once the arrivals queue is generated, the idea is to consider a time `t` from the queue and process its delay and
#' service time by jumping in time.
#' We keep track of the server's usage via the `busy` value which contain the time until when the server is busy.
#'
#' @param n int              : The number of jobs that will enter the queue
#' @param loopback_p float   : The probability of loopback
#'                             This MUST in the interval [0,1].
#'                               - 0 meaning that there is no loopback
#'                               - 1 meaning that every jobs are put in the queue after service completion
#' @param arrival_mean float : The \mu parameter of the normal law that generate the interarrivals
#' @param arrival_sd float   : The \sigma parameter for the normal law that generate the interarrivals
#' @param service_mean float : The \mu parameter of the normal law that provide the service time
#' @param service_sd float   : The \sigma parameter of the normal law that provide the service time
#'
#' @return dataframe : A dataframe containing the following columns :
#'                          - n_arrivals (integer) : the number of initial arrivals (without the loopback)
#'                          - n_services (integer) : the number of service done (with the loopback)
#'                          - n_loop (integer) : the count of loopback
#'                          - server_usage (float): the ratio of time when the server is used
#'                          - average_delay (float): the average time that a job spend in the queue of the system
#'                            note that the `average_delay` depend on the number of initial arrivals
#'                          - average_service_time (float) : the average time that a job spend in the server
#'                            also note that the `average_service_time` depend only on the number of initial arrivals
ssqlb <- function(n, loopback_p = 0.1, arrival_mean = 30, arrival_sd = 10, service_mean = 30, service_sd = 10) {
  # generate the interarrivals
  interarrivals <- rnorm(n, arrival_mean, arrival_sd)

  # add every arrival in the queue
  queue <- interarrivals %>% partial_sum

  # initialization
  services <- delays <- numeric(0)
  loop <- busy <- 0

  # loop over every element in the queue
  while (length(queue) > 0) {
    # sort queue
    queue <- queue[order(queue)]

    # pop first element
    t <- queue[1]
    queue <- queue[-1]

    # if server is busy
    if (t < busy) {
      # count the delay
      delays <- c(delays, busy - t)
      # fastforward to the time when the server is not busy anymore
      t <- busy
    }

    # now the service time of this job can be calculated
    s <- rnorm(1, service_mean, service_sd)
    services <- c(services, s)
    # so the server will be busy untill this time
    busy <- t + s

    # if there is a loopback, the job is queued right after quitting the server
    # so its 'arrival' time is the time when the server will stop beeing busy
    if (loopback(loopback_p)) {
      loop <- loop + 1
      queue <- c(queue, busy)
    }
  }

  n_arrivals <- length(interarrivals)
  n_services <- length(services)
  n_loop <- loop
  # at this point, busy contains the time when the last job quits the server
  server_usage <- sum(services) / busy
  average_delay <- sum(delays) / length(interarrivals)
  average_service_time <- sum(services) / length(interarrivals)

  data.frame(n_arrivals, n_services, n_loop, server_usage, average_delay, average_service_time)
}

#' Plot 3 graphs
#'  - Server usage
#'  - number of loopbacks
#'  - average delay
#' for simulated simple server queue with feedback loop that have variable probability of feedback
#'
#' The number of point on the x axis (probability of loopback) is defined by the three parameters
#'
#' @param min float : the minimum probability of loopback
#' @param max float : the maximum probability of loopback
#' @param step float : the increment value to go from `min` to `max`
display_info <- function(min, max, step) {
  x <- seq(min, max, step)
  y_loops <- y_average_delay <- y_server_usage <- length(x)
  for (i in seq_along(x)) {
    d <- ssqlb(10000, loopback_p = x[i], service_mean = 20, service_sd = 5)
    y_server_usage[i] <- d['server_usage']
    y_average_delay[i] <- d['average_delay']
    y_loops[i] <- d['n_loop']
  }

  plot(x, y_server_usage, xlab = 'Probability of feedback', ylab = 'Server usage')
  plot(x, y_loops, xlab = 'Probability of feedback', ylab = 'Number of additional loops')
  plot(x, y_average_delay, xlab = 'Probability of feedback', ylab = 'Average delay')
}

# Beginning of the script
display_info(0, 0.5, 0.01)
display_info(0.3, 0.4, 0.001)

print("i am done !")